"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const cspell = require("cspell-lib");
const markdown_spellcheck_1 = require("markdown-spellcheck");
const minimatch = require("minimatch");
const path_1 = require("path");
const string_index_context_1 = require("./string-index-context");
const implicitSettingsFilename = "spellcheck.json";
const leftSquareBracket = "&#91;";
var SpellChecker;
(function (SpellChecker) {
    SpellChecker[SpellChecker["MDSpellCheck"] = 0] = "MDSpellCheck";
    SpellChecker[SpellChecker["CSpell"] = 1] = "CSpell";
})(SpellChecker = exports.SpellChecker || (exports.SpellChecker = {}));
exports.spellCheck = (file, sourceText, type, ignoredWords, ignoredRegexs) => __awaiter(this, void 0, void 0, function* () {
    const errorFunc = type === SpellChecker.MDSpellCheck ? exports.mdSpellCheck : exports.codeSpellCheck;
    const errors = yield errorFunc(sourceText, file);
    const presentableErrors = errors
        .filter(e => ignoredWords.indexOf(e.word.toLowerCase()) === -1)
        .filter(e => !ignoredRegexs.find(r => !!e.word.match(new RegExp(r.substring(1)))));
    const contextualErrors = presentableErrors.map(e => string_index_context_1.default.getBlock(sourceText, e.index, e.word.length));
    if (contextualErrors.length > 0) {
        markdown(`
### Typos for ${danger.github.utils.fileLinks([file])}

| Line | Typo |
| ---- | ---- |
${contextualErrors.map(contextualErrorToMarkdown).join("\n")}
      `);
    }
});
const contextualErrorToMarkdown = (error) => {
    const sanitizedMarkdown = error.info.replace(/\[/, leftSquareBracket);
    return `${error.lineNumber} | ${sanitizedMarkdown}`;
};
const getPRParams = path => (Object.assign({}, danger.github.thisPR, { path, ref: danger.github.pr.head.ref }));
exports.mdSpellCheck = (sourceText) => markdown_spellcheck_1.default.spell(sourceText, { ignoreNumbers: true, ignoreAcronyms: true });
exports.codeSpellCheck = (sourceText, path) => {
    const ext = path_1.extname(path);
    const languageIds = cspell.getLanguagesForExt(ext);
    const mergedSettings = cspell.mergeSettings(cspell.getDefaultSettings(), { source: { name: path, filename: path } });
    const config = cspell.constructSettingsForText(mergedSettings, sourceText, languageIds);
    return cspell.checkText(sourceText, config).then(info => {
        return info.items
            .filter(i => i.isError)
            .map(item => ({
            word: item.text,
            index: item.startPos,
        }));
    });
};
exports.githubRepresentationForPath = (value) => {
    if (value.includes("@")) {
        return {
            path: value.split("@")[1],
            owner: value.split("@")[0].split("/")[0],
            repo: value.split("@")[0].split("/")[1],
        };
    }
};
exports.parseSettingsFromFile = (path, repo) => __awaiter(this, void 0, void 0, function* () {
    const data = yield danger.github.utils.fileContents(path, repo);
    if (data) {
        const settings = JSON.parse(data);
        return {
            ignore: (settings.ignore || settings["cSpell.words"] || []).map(w => w.toLowerCase()),
            whitelistFiles: settings.whitelistFiles || [],
        };
    }
    else {
        return { ignore: [], whitelistFiles: [] };
    }
});
exports.getSpellcheckSettings = (options) => __awaiter(this, void 0, void 0, function* () {
    let ignoredWords = [];
    let whitelistedMarkdowns = [];
    if (options && options.settings) {
        const settingsRepo = exports.githubRepresentationForPath(options.settings);
        if (settingsRepo) {
            const globalSettings = yield exports.parseSettingsFromFile(settingsRepo.path, `${settingsRepo.owner}/${settingsRepo.repo}`);
            ignoredWords = ignoredWords.concat(globalSettings.ignore);
            whitelistedMarkdowns = whitelistedMarkdowns.concat(globalSettings.whitelistFiles);
        }
    }
    const params = getPRParams(implicitSettingsFilename);
    const localSettings = yield exports.parseSettingsFromFile(implicitSettingsFilename, `${params.owner}/${params.repo}`);
    // from local settings file
    ignoredWords = ignoredWords.concat(localSettings.ignore);
    whitelistedMarkdowns = whitelistedMarkdowns.concat(localSettings.whitelistFiles);
    // from function
    ignoredWords = ignoredWords.concat((options && options.ignore) || []);
    whitelistedMarkdowns = whitelistedMarkdowns.concat((options && options.whitelistFiles) || []);
    const hasLocalSettings = !!(localSettings.ignore.length || localSettings.whitelistFiles.length);
    return { ignore: ignoredWords, whitelistFiles: whitelistedMarkdowns, hasLocalSettings };
});
/**
 * Spell checks any created or modified markdown files.
 *
 * Has an optional setting object for things like ignore.
 */
function spellcheck(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const allChangedFiles = [...danger.git.modified_files, ...danger.git.created_files];
        const settings = yield exports.getSpellcheckSettings(options);
        const ignore = settings.ignore || [];
        const whitelistFiles = settings.whitelistFiles || [];
        const ignoredRegexes = ignore.filter(f => f.startsWith("/"));
        const ignoredWords = ignore.filter(f => !f.startsWith("/"));
        /** Pull out the files which we want to run cspell over */
        const globs = (options && options.codeSpellCheck) || [];
        const allCodeToCheck = getCodeForSpellChecking(allChangedFiles, globs).filter(f => whitelistFiles.indexOf(f) === -1);
        /** Grab any MD files */
        const allMD = allChangedFiles.filter(f => f.endsWith(".md") || f.endsWith(".markdown"));
        const markdowns = allMD.filter(md => whitelistFiles.indexOf(md) === -1);
        const filesToLookAt = {
            [SpellChecker.MDSpellCheck]: markdowns,
            [SpellChecker.CSpell]: allCodeToCheck,
        };
        for (const type of Object.keys(filesToLookAt)) {
            const files = filesToLookAt[type];
            for (const file of files) {
                const params = getPRParams(file);
                const contents = yield danger.github.utils.fileContents(params.path, `${params.owner}/${params.repo}`, params.ref);
                if (contents) {
                    yield exports.spellCheck(file, contents, Number(type), ignoredWords, ignoredRegexes);
                }
            }
        }
        const hasTypos = results.markdowns.find(m => {
            if (typeof m === "string") {
                return m.includes("### Typos for");
            }
            else {
                return m.message.includes("### Typos for");
            }
        });
        // https://github.com/artsy/artsy-danger/edit/master/spellcheck.json
        if (hasTypos && (settings.hasLocalSettings || options)) {
            const thisPR = danger.github.thisPR;
            const repo = options && options.settings && exports.githubRepresentationForPath(options.settings);
            const repoEditURL = `/${thisPR.owner}/${thisPR.owner}/edit/${danger.github.pr.head.ref}/${implicitSettingsFilename}`;
            const globalEditURL = repo && `/${repo.owner}/${repo.repo}/edit/master/${repo.path}`;
            const globalSlug = repo && `${repo.owner}/${repo.repo}`;
            let localMessage = "";
            if (settings.hasLocalSettings && repoEditURL) {
                localMessage = `<p>Make changes to this repo's settings in ${url(repoEditURL, implicitSettingsFilename)}.</p>`;
            }
            else if (options && (options.ignore || options.whitelistFiles)) {
                localMessage = `<p>Make changes to this repo's spellcheck function call in the dangerfile.</p>`;
            }
            const globalMessage = options && repo
                ? `<p>
Make changes to the global settings ${url(globalEditURL, repo.path)} in ${url(globalSlug, "/" + globalSlug)}.
</p>`
                : "";
            markdown(`
<details>
<summary>Got false positives?</summary>
${globalMessage}
${localMessage}
</details>
`);
        }
    });
}
exports.default = spellcheck;
const url = (text, href) => `<a href='${text}'>${href}</a>`;
const getCodeForSpellChecking = (allChangedFiles, globs) => {
    return allChangedFiles.filter(file => {
        for (const glob of globs) {
            if (minimatch(file, glob)) {
                return true;
            }
        }
    });
};
